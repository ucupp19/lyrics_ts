<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lyrics Display</title>
<style>
  body {
    font-family: 'coolvetica', sans-serif;
    padding: 20px;
    margin-left: 10px;
    background: transparent;
    color: #eee;
    text-align: center;
  }
@font-face {
  font-family: 'coolvetica';
  src: url('fonts/Coolvetica\ Rg\ It.otf') format('truetype');
}

  #lyrics {
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.5;
    text-align: center;
    scroll-behavior: smooth;
  }
  .line {
    padding: 5px 0;
    text-align: center;
    opacity: 1;
    transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
  }
  .current {
    color: #A9D8B7;
    font-size: 1em;
    opacity: 1;
    transform: scale(1.1);
  }
  h1 {
    text-align: center;
    color: #ff4081;
  }
</style>
</head>
<body>
<div id="lyrics">Loading lyrics...</div>

<script>
  let lyrics = [];
  let currentIndex = -1;

  async function fetchLyrics() {
    const res = await fetch('/lyrics');
    lyrics = await res.json();
    renderLyrics();
  }

  // WebSocket client to listen for track changes
  let currentTrack = '';
  const ws = new WebSocket('ws://localhost:8000');

  ws.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      if (data.track_name && data.track_name !== currentTrack) {
        currentTrack = data.track_name;
        fetchLyrics();
        currentIndex = -1; // reset current index on new song
      }
    } catch (e) {
      console.error('Error parsing WebSocket message:', e);
    }
  };

  ws.onerror = (error) => {
    console.error('WebSocket error:', error);
  };

  async function fetchPosition() {
    try {
      const res = await fetch('/position');
      const data = await res.json();
      return data.position;
    } catch {
      return null;
    }
  }

  function parsePosition(posStr) {
    if (!posStr) return 0;
    if (posStr.includes(':')) {
      const parts = posStr.split(':');
      if (parts.length === 2) {
        const minutes = parseInt(parts[0], 10);
        const seconds = parseFloat(parts[1]);
        return minutes * 60 + seconds;
      }
    }
    return parseFloat(posStr) || 0;
  }

  function renderLyrics() {
    const container = document.getElementById('lyrics');
    // Show only 3 lines: previous, current, next
    const start = Math.max(0, currentIndex - 1);
    const end = Math.min(lyrics.length - 1, currentIndex + 1);
    const visibleLines = [];
    for (let i = start; i <= end; i++) {
      visibleLines.push(`<div class="line${i === currentIndex ? ' current' : ''}" id="line-${i}">${lyrics[i].text}</div>`);
    }
    container.innerHTML = visibleLines.join('');
  }

  function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }

  function smoothScrollTo(element, target, duration) {
    const start = element.scrollTop;
    const change = target - start;
    const startTime = performance.now();

    function animateScroll(currentTime) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const easeProgress = easeInOutQuad(progress);
      element.scrollTop = start + change * easeProgress;
      if (elapsed < duration) {
        requestAnimationFrame(animateScroll);
      }
    }
    requestAnimationFrame(animateScroll);
  }

  async function updateCurrentLine() {
    const posStr = await fetchPosition();
    const position = parsePosition(posStr);
    let newIndex = -1;
    for (let i = lyrics.length - 1; i >= 0; i--) {
      if (position >= lyrics[i].time) {
        newIndex = i;
        break;
      }
    }
    if (newIndex !== currentIndex) {
      currentIndex = newIndex;
      renderLyrics();
      // Scroll the middle line into view with ease-in-out animation
      const container = document.getElementById('lyrics');
      const currLine = document.getElementById(`line-${currentIndex}`);
      if (currLine && container) {
        const targetScrollTop = currLine.offsetTop - container.clientHeight / 2 + currLine.clientHeight / 2;
        smoothScrollTo(container, targetScrollTop, 600);
      }
    }
  }

  // Periodically refresh lyrics every 10 seconds to catch updates in output.lrc
  setInterval(() => {
    fetchLyrics();
  }, 10000);

  async function start() {
    await fetchLyrics();
    setInterval(updateCurrentLine, 1000);
  }

  start();
</script>
</body>
</html>
